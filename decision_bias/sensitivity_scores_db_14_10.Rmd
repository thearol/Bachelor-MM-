---
title: "sensitivity_scores_db"
author: "Thea Rolskov Sloth"
date: "11/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r loading packages and data}
library(pacman)
p_load(plotly, jpeg, tm, brms, tidyverse, tidybayes, ggplot2, LaplacesDemon, rethinking, tidyr, reshape2, tibble, stringr, here, brmstools, data.table)

#setting working directory
setwd("~/Bachelor-MM-/decision_bias")

#data
data_db <- read.csv("data_db.csv")

```

#Pooling

```{r making long format, include = FALSE}

#create dataframe with only data from left player
left <- data_db %>% select(-contains('right'))


#create dataframe with only data from right player
right <- data_db %>% select(-contains('left'))


#rename columns to not contain left or right
names(left) <- gsub(pattern = "_left", replacement = "", x = names(left))

names(right) <- gsub(pattern = "_right", replacement = "", x = names(right))


#make same type of column in subject
right$SubjectID <- as.factor(right$SubjectID)
left$SubjectID <- as.factor(left$SubjectID)

#make column that specifies side
right$Side <- as.factor("right")
left$Side <- as.factor("left")


#Removing half the joint data to inform the model, there is only one. 
right$RT_joint <- NA
right$Correct_joint <- NA
right$response_joint_dummy <- NA

#Joining the dataframes
long_data_db <- rbind(left, right)

#Setting NA in correct answers
long_data_db$Correct_joint[is.na(long_data_db$response_joint_dummy)] <- NA

```

## Create models for sensitivity scores


```{r get priors, define priors and prior predictive check}

#use get prior function
get_prior(response_dummy ~ diff + (1 + diff|SubjectID_unique), family = "bernoulli", data = long_data_db)

#Defining priors
prior_sensitivity =  c(
  prior(normal(0,0.125), class = "b", coef = "diff"),
  prior(normal(0,0.17), class = "Intercept"),
  prior(normal(0,0.125), class = "sd", coef = "diff", group = "SubjectID_unique"),
  prior(normal(0,0.17), class = "sd", coef = "Intercept", group = "SubjectID_unique")
)


#Prior predictive check
prior_check_sensitivity <- brm(response_dummy ~ diff + (diff|SubjectID_unique), prior = prior_sensitivity,
           data = long_data_db, sample_prior = "only",iter = 4000, family = "bernoulli")

pp_check(prior_check_sensitivity,nsamples = 1000)

```


```{r sensitivity model}
#Making the model - using answer
m_sensitivity <- brm(
  response_dummy ~ diff + (1+diff|SubjectID_unique),
  data = long_data_db,
  prior = prior_sensitivity,
  family = "bernoulli", #As we had a binary outcome, we set this to "bernoulli"
  seed = 123,# Adding a seed makes results reproducible.
  cores=2,
  chains=2,
  control = list(adapt_delta = 0.9)
) 


m_sensitivity

```

```{r save the sensitivity estimates}
#Saving random effect for individual intercept
random_effects_intercept <- as.data.frame(ranef(m_sensitivity))[,1:2] 

#Saving random effect for individual slope
random_effects_slope <- as.data.frame(ranef(m_sensitivity))[,5:6]

#Saving fixed effects 
fixed_effects <- as.data.frame(fixef(m_sensitivity)) #Making data frame of fixed effects



sensitivity_scores = data.frame(matrix(vector(), 128, 3,
                dimnames=list(c(), c("Intercept", "Slope", "Side"))),
                stringsAsFactors=F)

#Add fixed effects of intercept to random effects of intercept
sensitivity_scores$Intercept <- random_effects_intercept[,1] + fixed_effects[1,1]


#Add fixed effects of slope to random effects of slope
sensitivity_scores$Slope <- random_effects_slope[,1] + fixed_effects[2,1]

#Adding rownames
sensitivity_scores <- cbind(Row.Names = rownames(random_effects_intercept), as.data.frame(sensitivity_scores))

#rename rownames to subject id
names(sensitivity_scores)[names(sensitivity_scores == "Row.Names")] <- "SubjectID_unique"

sensitivity_scores$SubjectID_unique <- as.character(sensitivity_scores$SubjectID_unique)

##### her bliver det en factor med 1 level

```

```{r merge sensitivity scores with long_data_db}
long_data_db <- merge(long_data_db,sensitivity_scores,by="SubjectID_unique")

```

```{r create dataframe that only contains the columns which we would like to merge into wide format}

#Make dataframe with intercept, slope, side, and unique subject
sensitivity_scores <- distinct(long_data_db, SubjectID_unique, Side, Intercept, Slope)

```


```{r make wide to merge with disagree data}
sensitivity_scores_wide <- dcast(setDT(sensitivity_scores), SubjectID_unique~Side, value.var = c("SubjectID_unique", "Slope", "Intercept"))

names(sensitivity_scores_wide)[names(sensitivity_scores_wide) == "SubjectID_unique.1_left"] <- "SubjectID_left_unique"


names(sensitivity_scores_wide)[names(sensitivity_scores_wide) == "SubjectID_unique.1_right"] <- "SubjectID_right_unique"

sensitivity_scores_wide$SubjectID_left_unique <- as.character(sensitivity_scores_wide$SubjectID_left_unique)

```

```{r merge sensitivity scores into db_data in wide format}
disagree_data_test <- merge(disagree_db, sensitivity_scores_wide, by = "SubjectID_unique_left")


write.csv(sensitivity_scores, file = "sensitivity_scores.csv")

```


```{r slopes for individuals in single plots}
marginal_effects(
  m_sensitivity,
  "diff", 
  conditions = distinct(long_data_db, SubjectID_unique),
  re_formula = NULL
  )
```

```{r marginal effects, classic }
marginal_effects(m_sensitivity)
```

```{r plots that did not work}


spaghetti(m_sensitivity, xvar = "diff", spage)

marginal_effects(m_sensitivity, spaghetti = TRUE, nsamples = 100)

out_f <- marginal_effects(
  m_sensitivity,
  "diff"
  )[[1]]

out_r <- marginal_effects(
  m_sensitivity,
  "diff", 
  conditions = distinct(long_data_db, SubjectID_unique),
  re_formula = NULL
  )[[1]]


out_r %>% 
  ggplot(aes(diff, response_dummy)) +
  geom_ribbon(
    data = out_f,
    aes(ymin = lower__, ymax = upper__),
    alpha = .33
  ) +
  geom_line(data = out_f, size = 0.01) +
  geom_line(aes(group = SubjectID_unique))


forest(m_sensitivity)

ranef(m_sensitivity)

marginal_effects(ranef(m_sensitivity))

sjp.lmer(m_sensitivity, vars = "c12hour", type = "ri.slope")

#Defining paths for plots
trans_path_pool_indi = file.path("~/SocKultExam/plots/transition/pool/trans_plot_pool_individual.jpeg")
pp_path_pool_indi = file.path("~/SocKultExam/plots/pp_check/pool/pp_plot_pool_individual.jpeg")
marginal_path_pool_indi = file.path("~/SocKultExam/plots/marginal/pool/marginal_plot_pool_individual.jpeg")
#...and for correct
correct_trans_path_pool_indi = file.path("~/SocKultExam/plots/correct_transition/pool/correct_trans_plot_pool_individual.jpeg")
correct_pp_path_pool_indi = file.path("~/SocKultExam/plots/correct_pp_check/pool/correct_pp_plot_pool_individual.jpeg")
correct_marginal_path_pool_indi = file.path("~/SocKultExam/plots/correct_marginal/pool/correct_marginal_plot_pool_individual.jpeg")
  




  
#Marginal effects plot: Plotted and saved
jpeg(file=marginal_path_pool_indi)
print(marginal_effects(m_sensitivity))
dev.off()
    
  
#transition plot: Plotted and saved
jpeg(file=trans_path_pool_indi)
print(plot(m_sensitivity))
dev.off()

#pp_check plot: Plotted and saved
jpeg(file=pp_path_pool_indi)
print(pp_check(prior_check_answer_pool_individual, nsamples = 100))
dev.off()

```



```{r merge sensitivity scores with disagree data}

disagree_db <- read.csv("disagree_db.csv")
```



```{r creating wide format, include = FALSE, this does not work}
#Merging ldata output with wide data frame
data$Group <-data$GroupNumber

#Inserting estimates in wide format
data$Intercept_pooling_rf_left[data$GroupNumber == unique(str_extract(pooling_individual$Row.Names, "\\d"))] <- pooling_individual$Intercept_ranef_fixef_estimate_answer[data$SubjectID_left == removeNumbers(gsub('[_]', '', pooling_individual$Row.Names))]


```

